import xmlrpc.client as xc
import threading
import os
from pathlib import Path


class Discover:

    def __init__(self, rhost, rport, run_threaded):
        self.rhost = rhost
        self.rport = rport
        self.run_threaded = run_threaded
        self.continue_exec = True # will set False and reset to True if want to stop ongoing thread and start new 
        self.curr_instance_no = 0 # Instance no, increment and set to status to stop previous thread from continuing to write to status
        self.exec_status = {}

    def status_rst(self, wlist, delay):
        return {
            "Delay": delay,
            "Wordlist": wlist,
            "Running": -1,
            "Tested": 0,
            "Succeeded": 0,
            "HitList": [],
        }

    def log_success(self, rpc_method, instance_no):
        if self.curr_instance_no == instance_no:
            self.exec_status["HitList"].append(rpc_method)
            self.exec_status["Succeeded"] += 1


    def try_call(self, proxy, method, delay, curr_inst):
        if delay:
            os.system("ping %s %s 127.0.0.1 >nul" % ("-n" if os.name == "nt" else "-c", int(delay)+1))

        try:
            getattr(proxy, method)()
            if self.run_threaded:
                print(method) # Output realtime

            self.log_success(method) # Save for shw_status later

        except xc.Fault as fault:
            if "exceptions.TypeError" in str(fault): # TypeError, method exist but incorrect args
                self.log_success(method, curr_inst)

        except Exception:
            pass

        self.exec_status["Tested"] += 1

    def discover(self, proxy, path, delay, curr_inst):
        self.exec_status["Running"] = 1 # Start

        with open(path, "r") as wlist:
            priv_line_len = 0
            for line in wlist:
                if not self.continue_exec and self.curr_instance_no!=curr_inst:
                    return # End this thread, caller wants to start new

                line = line.strip()
                if not self.run_threaded:
                    print(f"\r{' '*priv_line_len}\r{line}", end="") # Fancy-ish output

                self.try_call(proxy, line, delay, curr_inst)
                priv_line_len = len(line) # Fancy-ish output

        self.exec_status["Running"] = 0 # Complete

    def shw_status(self):
        if not self.exec_status or self.exec_status["Running"]==-1:
            return

        status = self.exec_status
        # Same status format for "disc" and "tdisc" command
        print(f"{status['Wordlist']}, delay by {status['Delay']}s")
        print(f"Status: {'Ongoing' if status['Running']==1 else 'Done'}")
        print(f"Progress: {status['Succeeded']} hit(s) of {status['Tested']} test(s)")

        print("", end="\n" if status["HitList"] else "")
        for method in status["HitList"]:
            print(method)

    def run(self, wordlist, delay):
        proxy = xc.ServerProxy(f"http://{self.rhost}:{self.rport}/")
        wpath = Path(wordlist)

        if not wpath.exists():
            print("Wordlist file not found.")
            return
    
        if self.exec_status and self.exec_status["Running"]==1:
            self.continue_exec = False # End current thread

        print(f"Discovering {wpath} delay by {delay}")
        self.exec_status = self.status_rst(wpath, delay)

        self.curr_instance_no += 1
        if self.run_threaded:
            thread = threading.Thread(target=self.discover, args=(proxy, wpath, delay, self.curr_instance_no,))
            thread.start()
        else:
            self.discover(proxy, wpath, delay, self.curr_instance_no)

#TODO Connection test host:port
